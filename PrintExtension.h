/********************************************************************************    Copyright 2015 Christopher Andrews (http://arduino.land)    Released under MIT licence.********************************************************************************/#ifndef HEADER_PRINTEXTENSION    #define HEADER_PRINTEXTENSION    #include "Arduino.h"    #ifndef _INLINE_        #define _INLINE_        __attribute__( ( always_inline ) ) inline    #endif    typedef size_t pft;    typedef uint8_t pfct;    /*        pfct:        If you want to use large outputs, and do not care about the return count,        leave the setting as is. This will allow more optimised code, but writes        larger than 255 characters will have incorrect counts returned.        Otherwise replace uint8_t with a larger integer.    */    class PrintExtension : public Print{        public:            template< typename T >                _INLINE_ PrintExtension &operator +=( const T &t )                    { return concat( t ); }            template< typename T >                _INLINE_ PrintExtension &concat( const T &t )                    { return print( t ), *this; }            template< typename T >                _INLINE_ PrintExtension &concat( const T &t, const int i )                    { return print( t, i ) *this; }            template< typename T >                _INLINE_ PrintExtension &concatln( const T &t )                    { return println( t ), *this; }            template< typename T >                _INLINE_ PrintExtension &concatln( const T &t, const int i )                    { return println( t, i ), *this; }            pft printf( const char *format, ... );            void repeat( const char &character, unsigned char count );        protected:            friend int sprintf( char * str, const char * format, ... );            pft _printf( const char *format, const va_list &v_List );        private:            void cwrite( uint8_t data, pfct &counter );    };    class PrintEx : public PrintExtension{        public:            PrintEx( Print& print ) : out(print) { return; }            size_t write( uint8_t data )         { return out.write( data ); }        protected:            friend class Print;        private:            Print &out;    };    struct StreamEx : Stream, PrintExtension{        StreamEx( Stream &in ) : stream(in) {}        int available( void )               { return stream.available(); }        void flush( void )                  { stream.flush(); }        int peek( void )                    { return stream.peek(); }        int read( void )                    { return stream.read(); }        size_t write( uint8_t data )        { return stream.write(data); }        Stream &stream;    };#endif//EOF    